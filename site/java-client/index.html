<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../img/favicon.ico">
        <title>Java GraphQL Client - The DGS Framework</title>
        <link href="../css/bootstrap.min.css" rel="stylesheet">
        <link href="../css/font-awesome.min.css" rel="stylesheet">
        <link href="../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
        <link href="../stylesheets/extra.css" rel="stylesheet">

        <script src="../js/jquery-1.10.2.min.js" defer></script>
        <script src="../js/bootstrap.min.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="..">The DGS Framework</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-toggle="collapse" data-target="#navbar-collapse">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="navitem">
                                <a href=".." class="nav-link">Home</a>
                            </li>
                            <li class="navitem">
                                <a href="../tutorial/" class="nav-link">Getting Started</a>
                            </li>
                            <li class="navitem">
                                <a href="../query-execution-testing/" class="nav-link">Testing</a>
                            </li>
                            <li class="navitem">
                                <a href="../data-loaders/" class="nav-link">Async Data Fetching</a>
                            </li>
                            <li class="navitem">
                                <a href="../mutations/" class="nav-link">Mutations</a>
                            </li>
                            <li class="navitem">
                                <a href="../generating-code-from-schema/" class="nav-link">Code Generation</a>
                            </li>
                            <li class="navitem active">
                                <a href="./" class="nav-link">Java GraphQL Client</a>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Advanced <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../advanced/custom-datafetcher-context/" class="dropdown-item">Data Fetching Context</a>
</li>
                                    
<li>
    <a href="../advanced/customizing/" class="dropdown-item">Custom Extensions</a>
</li>
                                    
<li>
    <a href="../advanced/error-handling/" class="dropdown-item">Error Handling</a>
</li>
                                    
<li>
    <a href="../advanced/file-uploads/" class="dropdown-item">File Uploads</a>
</li>
                                    
<li>
    <a href="../advanced/subscriptions/" class="dropdown-item">Subscriptions</a>
</li>
                                    
<li>
    <a href="../advanced/type-resolvers-for-abstract-types/" class="dropdown-item">Type Resolvers for Abstract Types</a>
</li>
                                </ul>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ml-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li class="nav-item">
                                <a rel="prev" href="../generating-code-from-schema/" class="nav-link">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li class="nav-item">
                                <a rel="next" href="../advanced/custom-datafetcher-context/" class="nav-link">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                            <li class="nav-item">
                                <a href="/edit/java-client.md" class="nav-link"><i class="fa fa-github"></i> Edit on GitHub</a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-light navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-toggle="collapse" data-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-secondary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-level="2"><a href="#usage" class="nav-link">Usage</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            
            <li class="nav-item" data-level="2"><a href="#http-client-wrapper" class="nav-link">HTTP client wrapper</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            
            <li class="nav-item" data-level="2"><a href="#type-safe-query-api" class="nav-link">Type safe Query API</a>
              <ul class="nav flex-column">
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h2 id="usage">Usage</h2>
<p>The DGS framework provides a GraphQL client that can be used to retrieve data from a GraphQL endpoint.
The client has two components, each usable by itself, or in combination together.</p>
<ul>
<li>GraphQLClient - A HTTP client wrapper that provides easy parsing of GraphQL responses</li>
<li>Query API codegen - Generate type-safe Query builders</li>
</ul>
<h2 id="http-client-wrapper">HTTP client wrapper</h2>
<p>The GraphQL client wraps any HTTP client and provides easy parsing of GraphQL responses.
The client can be used against any GraphQL endpoint (it doesn't have to be implemented with the DGS framework),
but provides extra conveniences for parsing Gateway and DGS responses.
This includes support for the <a href="https://manuals.netflix.net/view/studioedge/mkdocs/master/best-practices/errors/">Errors Spec</a>.</p>
<p>To use the client, add the <code>com.netflix.graphql.dgs:graphql-dgs-client:latest.release</code> dependency to <code>build.gradle</code> and create an instance of <code>DefaultGraphQLClient</code>.</p>
<pre><code class="language-java">GraphQLClient client = new DefaultGraphQLClient(url);
</code></pre>
<p>The <code>url</code> is the server url of the endpoint you want to call.
This url will be passed down to the callback discussed below.</p>
<p>!!!info
    Note that for NIWS clients there typically is no url, because the endpoint is configured through properties.
    Just pass an empty string in this case.</p>
<p>Using the <code>GraphQLClient</code> a query can be executed.
The <code>executeQuery</code> method has three arguments:</p>
<ol>
<li>The query String</li>
<li>An optional map of query variables</li>
<li>An instance of <code>RequestExecutor</code>, typically provided as a lambda.</li>
</ol>
<p>Because of the large number HTTP clients in use within Netflix, the GraphQLClient is decoupled from any particular HTTP client implementation.
Any HTTP client (RestTemplate, RestClient, NIWS, OkHTTP, ....) can be used.
The developer is responsible for making the actual HTTP call by implementing a <code>RequestExecutor</code>.
<code>RequestExecutor</code> receives the <code>url</code>, a map of <code>headers</code> and the request <code>body</code> as parameters, and should return an instance of <code>HttpResponse</code>.
Based on the HTTP response the GraphQLClient parses the response and provides easy access to data and errors.
The example below uses <code>RestTemplate</code> with Metatron.</p>
<pre><code>@Metatron(&quot;mountainprojectdgs&quot;)
private RestTemplate dgsRestTemplate;

private static final String URL = &quot;https://mountainprojectdgs.cluster.us-east-1.test.cloud.netflix.net:8443/graphql&quot;;

private static final String QUERY = &quot;{\n&quot; +
            &quot;  ticks(first: %d, after:%d){\n&quot; +
            &quot;    edges {\n&quot; +
            &quot;      node {\n&quot; +
            &quot;        route {\n&quot; +
            &quot;          name\n&quot; +
            &quot;          grade\n&quot; +
            &quot;          pitches\n&quot; +
            &quot;          location\n&quot; +
            &quot;        }\n&quot; +
            &quot;        \n&quot; +
            &quot;        userStars\n&quot; +
            &quot;      }\n&quot; +
            &quot;    }\n&quot; +
            &quot;  }\n&quot; +
            &quot;}&quot;;

public List&lt;TicksConnection&gt; getData() {
    DefaultGraphQLClient graphQLClient = new DefaultGraphQLClient(URL);
    GraphQLResponse response = graphQLClient.executeQuery(query, new HashMap&lt;&gt;(), (url, headers, body) -&gt; {
        /**
         * The requestHeaders providers headers typically required to call a GraphQL endpoint, including the Accept and Content-Type headers.
         * To use RestTemplate, the requestHeaders need to be transformed into Spring's HttpHeaders.
         */
        HttpHeaders requestHeaders = new HttpHeaders();
        headers.forEach(requestHeaders::put);

        /**
         * Use RestTemplate to call the GraphQL service. 
         * The response type should simply be String, because the parsing will be done by the GraphQLClient.
         */
        ResponseEntity&lt;String&gt; exchange = dgsRestTemplate.exchange(url, HttpMethod.POST, new HttpEntity(body, requestHeaders), String.class);

        /**
         * Return a HttpResponse, which contains the HTTP status code and response body (as a String).
         * The way to get these depend on the HTTP client.
         */
        return new HttpResponse(exchange.getStatusCodeValue(), exchange.getBody());
    }); 

    TicksConnection ticks = graphQLResponse.extractValueAsObject(&quot;ticks&quot;, TicksConnection.class);
    return ticks;
}
</code></pre>
<p>The <code>GraphQLClient</code> provides methods to parse and retrieve data and errors in a variety of ways.
Refer to the <code>GrqphQLClient</code> JavaDoc for the complete list of supported methods.</p>
<table>
<thead>
<tr>
<th>method</th>
<th>description</th>
<th>example</th>
</tr>
</thead>
<tbody>
<tr>
<td>getData</td>
<td>Get the data as a Map<String, Object></td>
<td><code>Map&lt;String,Object&gt; data = response.getData()</code></td>
</tr>
<tr>
<td>dataAsObject</td>
<td>Parse data as the provided class, using the Jackson Object Mapper</td>
<td><code>TickResponse data = response.dataAsObject(TicksResponse.class)</code></td>
</tr>
<tr>
<td>extractValue</td>
<td>Extract values given a <a href="https://github.com/json-path/JsonPath">JsonPath</a>. The return type will be whatever type you expect, but depends on the JSON shape. For JSON objects, a Map is returned. Although this looks type safe, it really isn't. It's mostly useful for "simple" types like String, Int etc., and Lists of those types.</td>
<td><code>List&lt;String&gt; name = response.extractValue("movies[*].originalTitle")</code></td>
</tr>
<tr>
<td>extractValueAsObject</td>
<td>Extract values given a JsonPath and deserialize into the given class</td>
<td><code>Ticks ticks = response.extractValueAsObject("ticks", Ticks.class)</code></td>
</tr>
<tr>
<td>extractValueAsObject</td>
<td>Extract values given a JsonPath and deserialize into the given TypeRef. Useful for Maps and Lists of a certain class.</td>
<td><code>List&lt;Route&gt; routes = response.extractValueAsObject("ticks.edges[*].node.route", new TypeRef&lt;List&lt;Route&gt;&gt;(){})</code></td>
</tr>
<tr>
<td>getRequestDetails</td>
<td>Extract a <code>RequestDetails</code> object. This only works if requestDetails was requested in the query, and against the Gateway.</td>
<td>RequestDetails requestDetails = <code>response.getRequestDetails()</code></td>
</tr>
<tr>
<td>getParsed</td>
<td>Get the parsed <code>DocumentContext</code> for further JsonPath processing</td>
<td><code>response.getDocumentContext()</code></td>
</tr>
</tbody>
</table>
<h3 id="errors">Errors</h3>
<p>The GraphQLClient checks both for HTTP level errors (based on the response status code) and the <code>errors</code> block in a GraphQL response.
The GraphQLClient is compatible with the <a href="https://manuals.netflix.net/view/studioedge/mkdocs/master/best-practices/errors/">Errors Spec</a> used by the Gateway and DGS, and makes it easy to extract error information such as the ErrorType.</p>
<p>For example, for following GraphQL response the GraphQLClient lets you easily get the ErrorType and ErrorDetail fields.
Note that the <code>ErrorType</code> is an enum as specified by the <a href="https://manuals.netflix.net/view/studioedge/mkdocs/master/best-practices/errors/">Errors Spec</a>.</p>
<pre><code class="language-graphql">{
  &quot;errors&quot;: [
    {
      &quot;message&quot;: &quot;java.lang.RuntimeException: test&quot;,
      &quot;locations&quot;: [],
      &quot;path&quot;: [
        &quot;hello&quot;
      ],
      &quot;extensions&quot;: {
        &quot;errorType&quot;: &quot;BAD_REQUEST&quot;,
        &quot;errorDetail&quot;: &quot;FIELD_NOT_FOUND&quot;
      }
    }
  ],
  &quot;data&quot;: {
    &quot;hello&quot;: null
  }
}
</code></pre>
<pre><code class="language-java">assertThat(graphQLResponse.errors.get(0).extensions.errorType).isEqualTo(ErrorType.BAD_REQUEST)
assertThat(graphQLResponse.errors.get(0).extensions.errorDetail).isEqualTo(&quot;FIELD_NOT_FOUND&quot;)
</code></pre>
<h2 id="type-safe-query-api">Type safe Query API</h2>
<p>Based on a GraphQL schema a type safe query API can be generated for Java/Kotlin.
The generated API is a builder style API that lets you build a GraphQL query and it's projection (field selection).
Because the code gets re-generated when the schema changes, it helps catch errors in the query.
Because Java doesn't support multi-line strings (yet) it's also arguably a more readable way to specify a query.</p>
<p>If you own a DGS and want to generate a client for this DGS (e.g. for testing purposes) the client generation is just an extra property on the <a href="generating-code-from-schema">Codegen configuration</a>.
Specify the following in your <code>build.gradle</code>.</p>
<pre><code class="language-groovy">buildscript {
   dependencies{
      classpath 'netflix:graphql-dgs-codegen-gradle:latest.release'
   }
}

apply plugin: 'codegen-gradle-plugin'

generateJava{
   packageName = 'com.example.packagename' // The package name to use to generate sources
   generateClient = true
}
</code></pre>
<p>Code will be generated on build.
The generated code is in <code>build/generated</code>.</p>
<p>NOTE: Make sure the codegen plugin is the first plugin on the build script class path. One of the grpc plugins pulls in an old version of ANTLR.</p>
<p>If you want to generate a client for another DGS/GraphQL service you'll need to pull the service's schema somehow.
If the service is a DGS registered in Reggie, the DGS schema tools can be used.</p>
<pre><code class="language-groovy">buildscript {
    dependencies {
        classpath 'netflix.studioregistry:netflix.studioregistry.schema-tools:latest.release'
        classpath 'netflix:graphql-dgs-codegen-gradle:latest.release'
    }
}

apply plugin: 'netflix.studioregistry.schema-tools'
apply plugin: 'codegen-gradle-plugin'


pullSchema {
    dgsName = 'mountainprojectdgs'
    env = 'test'
    variant = &quot;integration&quot;
    schemaPath = &quot;${buildDir}/graphql-schemas/mountainproject.graphqls&quot;
}

generateJava{
    schemaPaths = [&quot;${buildDir}/graphql-schemas&quot;]
    packageName = 'com.netflix.mountainprojectdgsclient.generated' // The package name to use to generate sources
    typeMapping = [&quot;LocalDate&quot;: &quot;java.lang.String&quot;]
    generateClient = true
}

generateJava.dependsOn(&quot;pullSchema&quot;)
</code></pre>
<p>With the configuration above, the schema will be pulled from Reggie into the build directory, and code will be generated from that schema.
This is great to assure that the generated code stays in sync with the schema.
If the service is a stand-alone DGS, or not a DGS at all, you will have to manually copy the schema to your project and keep it in sync.</p>
<p>With codegen configured correctly, a builder style API will be generated when building the project.</p>
<p>Using the same query example as above, the query can be build using the generated builder API.</p>
<pre><code>GraphQLQueryRequest graphQLQueryRequest =
                new GraphQLQueryRequest(
                    new TicksGraphQLQuery.Builder()
                        .first(first)
                        .after(after)
                        .build(),
                    new TicksConnectionProjectionRoot()
                        .edges()
                            .node()
                                .date()
                                .route()
                                    .name()
                                    .votes()
                                        .starRating()
                                        .parent()
                                    .grade());

String query = graphQLQueryRequest.serialize();
</code></pre>
<p>The <code>GraphQLQueryRequest</code> is a class from <code>graphql-dgs-client</code>.
The <code>TicksGraphQLQuery</code> and <code>TicksConnectionProjectionRoot</code> are generated.
After building the query, it can be serialized to a String, and executed using the GraphQLClient.</p>
<p>Note that the <code>edges</code> and <code>node</code> fields are because the example schema is using Relay pagination.</p>
<h3 id="interface-projections">Interface projections</h3>
<p>When a field returns an interface, fields on the concrete types are specified using a fragment.</p>
<pre><code class="language-graphql">type Query @extends {
    script(name: String): Script
}

interface Script {
    title: String
    director: String
    actors: [Actor]
}

type MovieScript implements Script {
    title: String
    director: String
    length: Int
}

type ShowScript implements Script {
    title: String
    director: String
    episodes: Int
}
</code></pre>
<pre><code class="language-graphql">query { 
    script(name: &quot;Top Secret&quot;) { 
        title 
        ... on MovieScript {
            length
        } 
    } 
}
</code></pre>
<p>This syntax is supported by the Query builder as well.</p>
<pre><code class="language-java"> GraphQLQueryRequest graphQLQueryRequest =
    new GraphQLQueryRequest(
        new ScriptGraphQLQuery.Builder()
            .name(&quot;Top Secret&quot;)
            .build(),
        new ScriptProjectionRoot()
            .title()
            .onMovieScript()
                .length();                    
    );
</code></pre>
<h3 id="building-federated-queries">Building Federated Queries</h3>
<p>You can use <code>GraphQLQueryRequest</code> along with <code>EntitiesGraphQLQuery</code> to generated federated queries. 
The API provides a type-safe way to construct the <a href="https://www.apollographql.com/docs/apollo-server/federation/federation-spec/#resolve-requests-for-entities">_entities</a> query with the associated <code>representations</code> based on the input schema. 
The <code>representations</code> are passed in as a map of variables. Each representation class is generated based on the <code>key</code> fields defined  on the entity in your schema, along with the <code>__typename</code>. 
The <code>EntitiesProjectionRoot</code> is used to select query fields on the specified type.</p>
<p>For example, let us look at a schema that extends a <code>Movie</code> type:</p>
<pre><code class="language-graphql">type Movie @key(fields: &quot;movieId&quot;) @extends {
    movieId: Int @external
    script: MovieScript
}

type MovieScript  {
    title: String
    director: String
    actors: [Actor]
}

type Actor {
    name: String
    gender: String
    age: Int
}
</code></pre>
<p>With client code generation, you will now have a <code>MovieRepresentation</code> containing the key field, i.e., <code>movieId</code>, and the <code>__typename</code> field already set to type <code>Movie</code>. 
Now you can add each representation to the <code>EntitiesGraphQLQuery</code> as a <code>representations</code> variable.
You will also have a <code>EntitiesProjectionRoot</code> with <code>onMovie()</code> to select fields on <code>Movie</code> from.
Finally, you put them all together as a <code>GraphQLQueryRequest</code>, which you serialize into the final query string.
The map of <code>representations</code> variables is available via <code>getVariables</code> on the <code>EntitiesGraphQLQuery</code>.</p>
<p>Here is an example for the schema shown earlier:</p>
<pre><code class="language-java">        EntitiesGraphQLQuery entitiesQuery = new EntitiesGraphQLQuery.Builder()
                    .addRepresentationAsVariable(
                            MovieRepresentation.newBuilder().movieId(1122).build()
                    )
                    .build();
        GraphQLQueryRequest request = new GraphQLQueryRequest(
                    entitiesQuery,
                    new EntitiesProjectionRoot().onMovie().movieId().script().title()
                    );

        String query  = request.serialize();
        Map&lt;String, Object&gt; representations = entitiesQuery.getVariables();
</code></pre></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>
            var base_url = "..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../js/base.js" defer></script>
        <script src="../js/mermaid.min.js" defer></script>
        <script src="../search/main.js" defer></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
